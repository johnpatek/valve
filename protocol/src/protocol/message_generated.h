// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_VALVE_PROTOCOL_INTERNAL_H_
#define FLATBUFFERS_GENERATED_MESSAGE_VALVE_PROTOCOL_INTERNAL_H_

#include "flatbuffers/flatbuffers.h"

namespace valve {
namespace protocol {
namespace internal {

struct open_request;
struct open_requestBuilder;

struct close_request;
struct close_requestBuilder;

struct status_request;
struct status_requestBuilder;

struct log_request;
struct log_requestBuilder;

struct request_frame;
struct request_frameBuilder;

enum request_types : int32_t {
  request_types_OpenRequest = 0,
  request_types_CloseRequest = 1,
  request_types_StatusRequest = 2,
  request_types_LogRequest = 3,
  request_types_MIN = request_types_OpenRequest,
  request_types_MAX = request_types_LogRequest
};

inline const request_types (&EnumValuesrequest_types())[4] {
  static const request_types values[] = {
    request_types_OpenRequest,
    request_types_CloseRequest,
    request_types_StatusRequest,
    request_types_LogRequest
  };
  return values;
}

inline const char * const *EnumNamesrequest_types() {
  static const char * const names[5] = {
    "OpenRequest",
    "CloseRequest",
    "StatusRequest",
    "LogRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNamerequest_types(request_types e) {
  if (flatbuffers::IsOutRange(e, request_types_OpenRequest, request_types_LogRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesrequest_types()[index];
}

enum request_payloads : uint8_t {
  request_payloads_NONE = 0,
  request_payloads_open_request = 1,
  request_payloads_close_request = 2,
  request_payloads_status_request = 3,
  request_payloads_log_request = 4,
  request_payloads_MIN = request_payloads_NONE,
  request_payloads_MAX = request_payloads_log_request
};

inline const request_payloads (&EnumValuesrequest_payloads())[5] {
  static const request_payloads values[] = {
    request_payloads_NONE,
    request_payloads_open_request,
    request_payloads_close_request,
    request_payloads_status_request,
    request_payloads_log_request
  };
  return values;
}

inline const char * const *EnumNamesrequest_payloads() {
  static const char * const names[6] = {
    "NONE",
    "open_request",
    "close_request",
    "status_request",
    "log_request",
    nullptr
  };
  return names;
}

inline const char *EnumNamerequest_payloads(request_payloads e) {
  if (flatbuffers::IsOutRange(e, request_payloads_NONE, request_payloads_log_request)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesrequest_payloads()[index];
}

template<typename T> struct request_payloadsTraits {
  static const request_payloads enum_value = request_payloads_NONE;
};

template<> struct request_payloadsTraits<valve::protocol::internal::open_request> {
  static const request_payloads enum_value = request_payloads_open_request;
};

template<> struct request_payloadsTraits<valve::protocol::internal::close_request> {
  static const request_payloads enum_value = request_payloads_close_request;
};

template<> struct request_payloadsTraits<valve::protocol::internal::status_request> {
  static const request_payloads enum_value = request_payloads_status_request;
};

template<> struct request_payloadsTraits<valve::protocol::internal::log_request> {
  static const request_payloads enum_value = request_payloads_log_request;
};

bool Verifyrequest_payloads(flatbuffers::Verifier &verifier, const void *obj, request_payloads type);
bool Verifyrequest_payloadsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum response_type : int32_t {
  response_type_OpenResponse = 0,
  response_type_CloseResponse = 1,
  response_type_StatusResponse = 2,
  response_type_LogResponse = 3,
  response_type_MIN = response_type_OpenResponse,
  response_type_MAX = response_type_LogResponse
};

inline const response_type (&EnumValuesresponse_type())[4] {
  static const response_type values[] = {
    response_type_OpenResponse,
    response_type_CloseResponse,
    response_type_StatusResponse,
    response_type_LogResponse
  };
  return values;
}

inline const char * const *EnumNamesresponse_type() {
  static const char * const names[5] = {
    "OpenResponse",
    "CloseResponse",
    "StatusResponse",
    "LogResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameresponse_type(response_type e) {
  if (flatbuffers::IsOutRange(e, response_type_OpenResponse, response_type_LogResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesresponse_type()[index];
}

struct open_request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef open_requestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMEOUT = 4
  };
  uint64_t timeout() const {
    return GetField<uint64_t>(VT_TIMEOUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMEOUT) &&
           verifier.EndTable();
  }
};

struct open_requestBuilder {
  typedef open_request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeout(uint64_t timeout) {
    fbb_.AddElement<uint64_t>(open_request::VT_TIMEOUT, timeout, 0);
  }
  explicit open_requestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<open_request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<open_request>(end);
    return o;
  }
};

inline flatbuffers::Offset<open_request> Createopen_request(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timeout = 0) {
  open_requestBuilder builder_(_fbb);
  builder_.add_timeout(timeout);
  return builder_.Finish();
}

struct close_request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef close_requestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMEOUT = 4
  };
  uint64_t timeout() const {
    return GetField<uint64_t>(VT_TIMEOUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMEOUT) &&
           verifier.EndTable();
  }
};

struct close_requestBuilder {
  typedef close_request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeout(uint64_t timeout) {
    fbb_.AddElement<uint64_t>(close_request::VT_TIMEOUT, timeout, 0);
  }
  explicit close_requestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<close_request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<close_request>(end);
    return o;
  }
};

inline flatbuffers::Offset<close_request> Createclose_request(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timeout = 0) {
  close_requestBuilder builder_(_fbb);
  builder_.add_timeout(timeout);
  return builder_.Finish();
}

struct status_request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef status_requestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERBOSE = 4
  };
  bool verbose() const {
    return GetField<uint8_t>(VT_VERBOSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERBOSE) &&
           verifier.EndTable();
  }
};

struct status_requestBuilder {
  typedef status_request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_verbose(bool verbose) {
    fbb_.AddElement<uint8_t>(status_request::VT_VERBOSE, static_cast<uint8_t>(verbose), 0);
  }
  explicit status_requestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<status_request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<status_request>(end);
    return o;
  }
};

inline flatbuffers::Offset<status_request> Createstatus_request(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool verbose = false) {
  status_requestBuilder builder_(_fbb);
  builder_.add_verbose(verbose);
  return builder_.Finish();
}

struct log_request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef log_requestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4
  };
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct log_requestBuilder {
  typedef log_request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(log_request::VT_COUNT, count, 0);
  }
  explicit log_requestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<log_request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<log_request>(end);
    return o;
  }
};

inline flatbuffers::Offset<log_request> Createlog_request(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t count = 0) {
  log_requestBuilder builder_(_fbb);
  builder_.add_count(count);
  return builder_.Finish();
}

struct request_frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef request_frameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  valve::protocol::internal::request_types type() const {
    return static_cast<valve::protocol::internal::request_types>(GetField<int32_t>(VT_TYPE, 0));
  }
  valve::protocol::internal::request_payloads payload_type() const {
    return static_cast<valve::protocol::internal::request_payloads>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const valve::protocol::internal::open_request *payload_as_open_request() const {
    return payload_type() == valve::protocol::internal::request_payloads_open_request ? static_cast<const valve::protocol::internal::open_request *>(payload()) : nullptr;
  }
  const valve::protocol::internal::close_request *payload_as_close_request() const {
    return payload_type() == valve::protocol::internal::request_payloads_close_request ? static_cast<const valve::protocol::internal::close_request *>(payload()) : nullptr;
  }
  const valve::protocol::internal::status_request *payload_as_status_request() const {
    return payload_type() == valve::protocol::internal::request_payloads_status_request ? static_cast<const valve::protocol::internal::status_request *>(payload()) : nullptr;
  }
  const valve::protocol::internal::log_request *payload_as_log_request() const {
    return payload_type() == valve::protocol::internal::request_payloads_log_request ? static_cast<const valve::protocol::internal::log_request *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           Verifyrequest_payloads(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const valve::protocol::internal::open_request *request_frame::payload_as<valve::protocol::internal::open_request>() const {
  return payload_as_open_request();
}

template<> inline const valve::protocol::internal::close_request *request_frame::payload_as<valve::protocol::internal::close_request>() const {
  return payload_as_close_request();
}

template<> inline const valve::protocol::internal::status_request *request_frame::payload_as<valve::protocol::internal::status_request>() const {
  return payload_as_status_request();
}

template<> inline const valve::protocol::internal::log_request *request_frame::payload_as<valve::protocol::internal::log_request>() const {
  return payload_as_log_request();
}

struct request_frameBuilder {
  typedef request_frame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(valve::protocol::internal::request_types type) {
    fbb_.AddElement<int32_t>(request_frame::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_payload_type(valve::protocol::internal::request_payloads payload_type) {
    fbb_.AddElement<uint8_t>(request_frame::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(request_frame::VT_PAYLOAD, payload);
  }
  explicit request_frameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<request_frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<request_frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<request_frame> Createrequest_frame(
    flatbuffers::FlatBufferBuilder &_fbb,
    valve::protocol::internal::request_types type = valve::protocol::internal::request_types_OpenRequest,
    valve::protocol::internal::request_payloads payload_type = valve::protocol::internal::request_payloads_NONE,
    flatbuffers::Offset<void> payload = 0) {
  request_frameBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_type(type);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline bool Verifyrequest_payloads(flatbuffers::Verifier &verifier, const void *obj, request_payloads type) {
  switch (type) {
    case request_payloads_NONE: {
      return true;
    }
    case request_payloads_open_request: {
      auto ptr = reinterpret_cast<const valve::protocol::internal::open_request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case request_payloads_close_request: {
      auto ptr = reinterpret_cast<const valve::protocol::internal::close_request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case request_payloads_status_request: {
      auto ptr = reinterpret_cast<const valve::protocol::internal::status_request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case request_payloads_log_request: {
      auto ptr = reinterpret_cast<const valve::protocol::internal::log_request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool Verifyrequest_payloadsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifyrequest_payloads(
        verifier,  values->Get(i), types->GetEnum<request_payloads>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace internal
}  // namespace protocol
}  // namespace valve

#endif  // FLATBUFFERS_GENERATED_MESSAGE_VALVE_PROTOCOL_INTERNAL_H_
